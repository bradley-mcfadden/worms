[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

// Fill part of the height of a texture will a gradient

// High gradient color
uniform vec4 fillColor: hint_color = vec4(0.70, 0.31, 0.31, 1.00);
// Low gradient color
uniform vec4 gradColor: hint_color = vec4(0.47, 0.21, 0.21, 1.00);
// Fraction of height to fill
uniform float proportion: hint_range(0, 1) = 0.0;
// Threshold below which RGBA values are considered transparent
uniform float lowerLimit: hint_range(0, 1) = 0.01;

/**
 * map values from one range to another.
 * @value value in range is, ie
 * @is Lower limit of input range
 * @ie Upper limit of input range
 * @os Lower limit of output range
 * @oe Upper limit of output range
 * @return Value in os, oe range proportional to its place in is, ie range.
 */ 
float map(float value, float is, float ie, float os, float oe) {
	float ir = ie - is;
	float or = oe - os;
	float ip = (value - is) / ir;
	float ov = ip * or + os;
	return ov;
}

void fragment() {
	float v = map(UV.y, 0.0, 1.0, 0.2, 0.8);
	float p = map(proportion, 0.0, 1.0, 0.2, 0.8);
	vec4 texcol = texture(TEXTURE, UV);
	vec4 vfill = step(lowerLimit, texcol);
	float sfill = vfill.x * vfill.y * vfill.z * vfill.w;
	vec4 fcolor = mix(fillColor, gradColor, v);
	float sine = sin(12.0 * UV.x + TIME * 4.0) * 0.05;
	float sinf = sin(24.0 * UV.x + TIME * 12.0) * 0.01;
	float xcolor = step(sine, 0);
	vec4 color = mix(texcol, fcolor, step(-sine + sinf + 1.0 - v, p) * sfill /** xcolor*/);
	COLOR = color;
}"
